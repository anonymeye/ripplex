/**
 * Tracing module
 * Inspired by re-frame's trace.cljc
 * 
 * Handles trace collection, debouncing, and delivery to registered callbacks
 */

import { EventTrace, TraceCallback } from './types'

export interface Tracer<State> {
  /**
   * Register a trace callback
   * Callbacks receive batches of traces (debounced)
   * @param key - Unique identifier for the callback
   * @param callback - Function to receive trace batches
   */
  registerTraceCallback(key: string, callback: TraceCallback<State>): void

  /**
   * Remove a trace callback
   * @param key - Unique identifier for the callback to remove
   */
  removeTraceCallback(key: string): void

  /**
   * Emit an event trace (internal use)
   * The trace ID is automatically generated by the tracer
   * @param trace - The trace to emit (without id field)
   */
  emitEventTrace(trace: Omit<EventTrace<State>, 'id'>): void
}

export interface TracingConfig {
  enabled?: boolean
  debounceTime?: number
}

/**
 * Create a new tracer instance
 * @param config - Tracing configuration
 * @returns A new Tracer instance
 */
export function createTracer<State>(
  config: TracingConfig = {}
): Tracer<State> {
  // Internal state
  const traceEnabled: boolean = config.enabled ?? false
  const traceCallbacks = new Map<string, TraceCallback<State>>()
  const traces: EventTrace<State>[] = []
  let traceIdCounter = 0
  const debounceTime: number = config.debounceTime ?? 50
  let debounceTimer: ReturnType<typeof setTimeout> | null = null
  let nextDeliveryTime: number = 0

  /**
   * Deliver traces to all registered callbacks
   */
  const deliverTraces = (): void => {
    if (traces.length === 0) return

    const tracesToDeliver = [...traces]
    traces.length = 0 // Clear array

    for (const [key, callback] of traceCallbacks.entries()) {
      try {
        callback(tracesToDeliver)
      } catch (error) {
        console.error(`Error in trace callback "${key}":`, error)
      }
    }

    debounceTimer = null
    nextDeliveryTime = 0
  }

  /**
   * Schedule debounced trace delivery
   * Similar to re-frame's debounced trace delivery
   */
  const scheduleTraceDelivery = (): void => {
    const now = Date.now()
    
    // If we're within 25ms of next delivery, reschedule
    if (now < nextDeliveryTime - 25) {
      return
    }

    // Clear existing timer
    if (debounceTimer !== null) {
      clearTimeout(debounceTimer)
    }

    // Schedule new delivery
    nextDeliveryTime = now + debounceTime
    debounceTimer = setTimeout(() => {
      deliverTraces()
    }, debounceTime)
  }

  /**
   * Emit an event trace
   * Automatically generates and assigns a trace ID
   */
  const emitEventTrace = (trace: Omit<EventTrace<State>, 'id'>): void => {
    if (!traceEnabled) return

    // Generate trace ID internally
    const traceWithId: EventTrace<State> = {
      ...trace,
      id: ++traceIdCounter
    }

    traces.push(traceWithId)
    scheduleTraceDelivery()
  }

  /**
   * Register a trace callback
   */
  const registerTraceCallback = (key: string, callback: TraceCallback<State>): void => {
    if (!traceEnabled) {
      console.warn('Tracing is not enabled. Set tracing.enabled to true in StoreConfig.')
      return
    }
    traceCallbacks.set(key, callback)
  }

  /**
   * Remove a trace callback
   */
  const removeTraceCallback = (key: string): void => {
    traceCallbacks.delete(key)
  }

  return {
    registerTraceCallback,
    removeTraceCallback,
    emitEventTrace
  }
}

